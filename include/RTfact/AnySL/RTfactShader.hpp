#ifndef RTFACTSHADER_HPP_
#define RTFACTSHADER_HPP_

#include "RTfact/Config/Detail/System.hpp"

#include <math.h>
//#include "commontypes.hpp" //TODO: remove completely
#include "TypeInfo.hpp"
#include "jitrt_rtfact_shader.hpp"
#include "Noise.hpp"
#include "ShaderUtil.hpp"
#include "ShaderMath.hpp"
#include "SamplingUtil.hpp"
#include "HaltonFaure.hpp"


/* C++ standard implicitly assumes single threaded execution. Thus static local variables can be
 * multiply initialized if more thread access that function. GCC solves it by putting the __cxa_guard* calls around them.
 * Visual Studio however does not, it simply ignores the issue.
 * Until the standard is fixed (as in this way it is a matter of taste, so both are still standard compliant), with MSVC the
 * guards have to be empty-defined.
 */
#ifdef RTFACT_OS_WIN

__extension__ typedef int __guard __attribute__((mode (__DI__)));

int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
void __cxa_guard_abort (__guard *) {};

#endif

//implementation specific

struct ParamInfo
{
    const char * name;         /// parameter name
    char semanticID;           /// parameter semantic (see TypeInfo.hpp)
    char elementTypeID;        /// parameter element type
    unsigned int numElements;  /// number of elements in parameter
    const char * typeName;
    const char * descr; /// optional parameter description (might be 0)

    ParamInfo(const char *name,
              char semanticID,
              char elementTypeID,
              unsigned int numElements,
              const char * typeName,
              const char * descr) :
        name(name),
        semanticID(semanticID),
        elementTypeID(elementTypeID),
        numElements(numElements),
        typeName(typeName),
        descr(descr)
    { }

    ParamInfo() :
        name(0), semanticID(0), elementTypeID(0),
        numElements(0), typeName(0), descr(0)
    { }
};

#define PARAMETER extern "C"

/// BEGIN_INIT_PARAM will generate function which will initialize all
/// parameters to default values and return param information table
#define BEGIN_INIT_PARAM                                                \
    extern "C" const ParamInfo * cxx_get_param_info_and_init()          \
    {                                                                   \
        static ParamInfo infos [] = {

/// INIT_PARAM_DESCR will produce the code for parameter initialization
/// and information table
#define INIT_PARAM_DESCR(name, defaultValue, descr)                     \
            ParamInfo(#name, static_cast<char>(getTypeSemanticID(name)),\
            static_cast<char>(getTypeElementTypeID(name)),              \
            getTypeNumElements(name),                                   \
            getTypeNameAndSet(name, defaultValue), descr),

/// INIT_PARAM will produce the code for parameter initialization
/// and information table
#define INIT_PARAM(name, defaultValue)                                  \
    INIT_PARAM_DESCR(name, defaultValue, 0)

/// END_INIT_PARAM finishes the function generated by BEGIN_INIT_PARAM
/// parameters to default values and return param information table
#define END_INIT_PARAM                                                  \
            ParamInfo(0, 0, 0, 0, 0, 0)                                 \
        };                                                              \
        return infos;                                                   \
    }

// CXX shader identification
// This is required for identification of the shader language
// from the loaded LLVM bitcode module.
extern "C" void cxx_shader_id() { }

//shader specific
#define snoise(x) PNoise(x)
#define boxstep(a,b,x) (Clamp(((x)-(a))/((b)-(a)),0,1))
#define MINFILTERWIDTH 1.0e-7

#if defined(__INTEL_COMPILER) || defined(_MSC_VER)
#define ANYSL_INLINE __forceinline //__inline
#else
#define ANYSL_INLINE __attribute__((always_inline)) //inline
#endif

#define SURFACE_SHADER \
extern "C" void shade_s( \
    void * __restrict   context, \
    const unsigned      rayType, \
    const bool          inside, \
    const int           primeBase, \
    const Vector        cumulativeFactor, \
    const int           randomSeed, \
    const unsigned      maxDepth, \
		const unsigned      depth, \
		const Point         origin, \
		const Point         dir, \
		const unsigned      appearanceID, \
		const float         hitDistance, \
		const Point         geomNormal, \
		const Point         normal, \
		const Color         vertColor, \
		const float         u, \
		const float         v, \
		const float         texCoord1, \
		const float         texCoord2, \
		Color &             result, \
		const Point         tangent, \
		const Point         binormal \
); \
extern "C" void shade \
( \
		void * __restrict  context, \
    const unsigned     rayType, \
    const bool         inside, \
    const int          primeBase, \
    const float        cumulativeFactorX, \
    const float        cumulativeFactorY, \
    const float        cumulativeFactorZ, \
    const int          randomSeed, \
    const unsigned     maxDepth, \
		const unsigned     depth, \
		const float        originX, \
		const float        originY, \
		const float        originZ, \
		const float        dirX, \
		const float        dirY, \
		const float        dirZ, \
		const unsigned     appearanceID, \
		const float        hitDistance, \
		const float        geomNormalX, \
		const float        geomNormalY, \
		const float        geomNormalZ, \
		const float        normalX, \
		const float        normalY, \
		const float        normalZ, \
		const float        vertColorX, \
		const float        vertColorY, \
		const float        vertColorZ, \
		const float        u, \
		const float        v, \
		const float        texCoord1, \
		const float        texCoord2, \
		float * __restrict oResultX, \
		float * __restrict oResultY, \
		float * __restrict oResultZ, \
		const float        tangentX, \
		const float        tangentY, \
		const float        tangentZ, \
		const float        binormalX, \
		const float        binormalY, \
		const float        binormalZ \
) { \
	Color result; \
    shade_s(context, rayType, inside, primeBase, \
      Vector(cumulativeFactorX, cumulativeFactorY, cumulativeFactorZ), randomSeed, maxDepth, depth, \
      Point(originX, originY, originZ), Point(dirX, dirY, dirZ), \
			appearanceID, hitDistance, Point(geomNormalX, geomNormalY, geomNormalZ), \
            Point(normalX, normalY, normalZ), Color(vertColorX, vertColorY, vertColorZ), \
            u, v, texCoord1, texCoord2, result, Point(tangentX, tangentY, tangentZ), Point(binormalX, binormalY, binormalZ)); \
	*oResultX = result.x; \
	*oResultY = result.y; \
	*oResultZ = result.z; \
} \
extern "C" void ANYSL_INLINE shade_s \
( \
		void * __restrict context, \
    const unsigned    rayType, \
    const bool        inside, \
    const int         primeBase, \
    const Vector      cumulativeFactor, \
    const int         randomSeed, \
    const unsigned    maxDepth, \
		const unsigned    depth, \
		const Point       origin, \
		const Point       dir, \
		const unsigned    appearanceID, \
		const float       hitDistance, \
		const Point       geomNormal, \
		const Point       normal, \
		const Color       vertColor, \
		const float       u, \
		const float       v, \
		const float       texCoord1, \
		const float       texCoord2, \
		Color &           result, \
		const Point       tangent, \
		const Point       binormal \
)

// valid only inside of a shade function
// NOTE: internal trace API does the depth increment and addition of EPS
#define TraceRay(origin, dir, outputColor) \
    Context::trace(context, origin, dir, depth, outputColor)
#define TraceParticle(origin, dir, cumulativeFactor, outputColor) \
    Context::traceParticle(context, origin, dir, cumulativeFactor, primeNumberIndex, randomSeed, inside, depth, outputColor)

#define SampleTexture(texture) \
    Context::sampleDiffuseTexture(context, texture, texCoord1, texCoord2, 0.f, 0.f)
#define SampleTextureCoord(texture, xCoord, yCoord) \
    Context::sampleDiffuseTexture(context, texture, xCoord, yCoord, 0.f, 0.f)
#define SampleTextureOffset(texture, xCoord, yCoord, xOffset, yOffset) \
    Context::sampleDiffuseTexture(context, texture, xCoord, yCoord, xOffset, yOffset)

#define Time Context::getTime(context)


inline Color diffuseComponent(const Vector &L_dir_norm,
                              const Point &P,
                              const Normal &N,
                              const Color &Cl)
{
    float cosLight = Dot(L_dir_norm, N);
    if (cosLight < 0.0)
        return Color(0.0f, 0.0f, 0.0f);
    return Cl*cosLight;
}

inline Color specularbrdf(const Vector &L_dir_norm,
                          const Vector &N,
                          const Vector &V,
                          float roughness,
                          float invRoughness)
{
    Vector H = Normalized(L_dir_norm + V);
    float NdotH = Dot(N, H);
    float val = NdotH > 0.0 ? powf(NdotH, invRoughness) : 0.0;
    return Color(val, val, val);
}

inline Color specularComponent(const Vector &L_dir_norm,
                               const Point &P,
                               const Normal &N,
                               const Vector &V,
                               const Color &Cl,
                               float roughness,
                               float invRoughness)
{
    return Cl * specularbrdf(L_dir_norm, N, V, roughness, invRoughness);
}


inline Color phongComponent(const Vector &L_dir_norm,
                            const Point &P,
                            const Normal &N,
                            const Vector &R, // reflection vector = Reflect(V,N)
                            const Color &Cl,
                            float kg)
{
    float cosLight = Dot(L_dir_norm, N);
    if (cosLight < 0.0)
        // light on wrong side
        return Color(0.0f, 0.0f, 0.0f);

    // iff angle lesser than 90 degree
    float cosHighlight = Dot(R, L_dir_norm);
    if (cosHighlight > 0.0)
    {
        // add specular (glossy) term
        return Cl*Pow(cosHighlight, kg);
    }
    return Color(0.0f, 0.0f, 0.0f);
}


/** Illuminance loop
 *  following variables are valid inside of the loop :
 *
 *  int numLights          Number of lights
 *  int L_id               Light ID
 *  Point L_pos            Light position
 *  Vector L_dir           Outgoing light direction
 *  Vector L_dir_norm      Normalized outgoing light direction
 *  float L_dist           Light distance
 *  Color Cl               Outgoing light color
 *
 *  NOTE: negation of L_dir_norm in getLightContribution is
 *        done inside internal API function
 */
#define BEGIN_ILLUMINANCE_LOOP(P)                                        \
{                                                                        \
    const unsigned numLights = Context::getNumLightSources(context); \
    for (unsigned L_id = 0u; L_id < numLights; ++L_id)               \
    {                                                                    \
        Point L_pos;                                                     \
        Vector L_dir;                                                    \
        float L_dist;                                                    \
        Color Cl;                                                        \
        Context::sampleLightSource(context, L_id, P, L_dir, L_dist,      \
                                   Cl, L_pos);                           \
        const Vector L_dir_norm = Normalized(L_dir);                     \
        if (Context::getLightContribution(context, L_pos,                \
                                          L_dir_norm, L_dist, Cl))      \
        {



#define END_ILLUMINANCE_LOOP } } }

#endif /* RTFACTSHADER_HPP_ */
